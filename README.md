## آزمایش ۵

### SOLID

#### Single Responsibility Principle

 <p dir="rtl"  style='text-align: right;'>
این اصل در طراحی SOLID به این معنی است که یک کلاس فقط باید به یک Actor پاسخگو باشد 
یا به عبارتی فقط باید یک کار انجام دهد. این کار باعث این می‌شود که اگر بخواهیم برای یک Actor تغییراتی 
در کد ایجاد کنیم فقط بخش‌های مربوط به آن عوض می‌شوند و مشکلی برای Actorهای دیگر پیش نمی‌آید. که این مورد 
به نگه‌داری برنامه و گسترش و آپدیت کردن کردن آن کمک می‌کند و این فرآیند را راحت‌تر می‌کند.
</p>

#### Open Closed Principle

<p dir="rtl" style='text-align: right;'>
این اصل به این معنی است که کلاس‌ها قابلیت گسترش داشته باشند بدون اینکه نیاز به تغییر داشته باشند. 
به این معنی که اگر بخواهیم یک قابلیت جدید به کد اضافه کنیم باید بتوانیم به سادگی با اضافه کردن یک قسمت جدید 
به کد بدون اینکه نیاز باشد کد قبلی را تغییر بدهیم، این کار را انجام دهیم. که رعایت این اصل کمک می‌کند ويژگی‌های جدید با کمترین زمان و با کمترین هزینه به برنامه اضافه شوند.
</p>

#### Liskov Substitution Principle

<p dir="rtl" style="text-align: right">
با پیاده سازی این اصل زمانی که از یک کلاس پدر استفاده می‌شود بدون اینکه اطلاعاتی 
راجع به فرزند آن بدانیم باید بتوانیم از ویژگی‌های پدر استفاده کنیم. به عبارتی 
این اصل را می‌توان اینطور بیان کرد:
<br>
 فرض کنیم (q(x یک ویژگی درست در مورد شی x از نوع پدر است.
آنگاه (q(y باید برای شی y از نوع فرزند درست باشد. (فرزند همان کلاس قبل)
</p>

#### Interface Segregation Principle

<p dir="rtl" style="text-align: right">
در این اصل یک کلاس نباید مجبور به پیاده سازی توابعی شود که از آن استفاده نمی‌کند. 
برای مثال یک کلاس نباید یک interface را پیاده سازی کند که از بعضی از توابع آن استفاده‌ای نخواهد کرد.
به همین دلیل استفاده از interface های کوچک‌تر بهتر از استفاده از interface‌های بزرگ‌تر است. 
این کار باعث این‌ می‌شود که در آینده ایجاد تغییرات راحت تر باشد.
</p>

#### Dependency Inversion Principle

<p dir="rtl" style="text-align: right">
در این اصل کلاس‌های سطح بالاتر نباید از ویژگی‌های کلاس سطح پایین‌تر نباید 
استفاده کنند و روابط بین کلاس‌ها باید از نوع abstraction باشد. همچنین در 
این abstraction ها نباید جزییات کلاس‌ها پیاده سازی شوند و این جزییات باید 
در کلاس‌های سطح پایین تر پیاده‌سازی شوند. این اصل باعث می‌شود در صورت تغییر در 
کلاس‌های سطح پایین‌تر نیازی نباشد تا در کلاس‌های سطح بالا نیز تغییری ایجاد کنیم.
</p>


### سوال ۲

<p dir="rtl" style="text-align: right">
از اصل Single Responsibility Principle بیشتر در فاز طراحی و کمی در فاز پیاده‌سازی استفاده می‌شود. زیرا 
این اصل بر مسئولیت‌های کلاس‌ها و ماژول‌ها تاکید می‌کند در نتیجه بیشتر در فاز طراحی مهم است. 
از اصل Open Closed Principle نیز بیشتر در فاز پیاده‌سازی استفاده می‌شود هرچند که فاز پیاده‌سازی نیز برای 
این اصل مهم است. از‌ آنجایی که این اصل بر این موضوع تاکید دارد که کلاس‌ها توسعه پذیر باشند، این مورد 
بیشتر به پیاده‌سازی درست مربوط می‌شود و تا حدودی طراحی درست.
از اصل Liskov Substitution Principle نیز بیشتر در فاز طراحی استفاده می‌شود. زیرا در این فاز باید روابط بین کلاس‌ها 
مشخص می‌شوند که این مورد در فاز طراحی انجام می‌شود. همچنین تا حدودی هم بر فاز پیاده‌سازی تاثیر می‌گذارد.
اصل Interface Segregation Principle نیز بیشتر در مرحله طراحی استفاده می‌شود زیرا در این مرحله باید 
interface ها طراحی شوند و اینکار باید به گونه‌ای انجام شود که 
کلاس‌ها توابعی را پیاده سازی نکنند که استفاده‌ای برای‌شان ندارند.
اصل Dependency Inversion Principle نیز مانند اصل قبلی بیشتر در مرحله طراحی استفاده می‌شود. زیرا برای این اصل 
ارتباط بین کلاس‌ها باید به گونه‌ای طراحی شود که تغییر در کلاس‌های سطح پایین منجر به تغییر به کلاس‌های 
پدر و سطح بالاتر نشود که این کار بیشتر در مرحله طراحی انجام می‌شود.
</p>

### سوال ۳

<p dir="rtl" style="text-align: right">
خیر؛ در روش TDD، نوشتن تست‌ها به نوعی جزئی از فرآیند Development هستند. در این روش ابتدا تست‌ها نوشته می‌شوند و 
باقی قسمت Development با استفاده از آن‌ها انجام می‌شود و کدها با توجه تست‌ها زده می‌شوند به طوری که 
بتوانند آنها را پاس کنند. در نتیجه این روش با مورد گفته شده تناقضی ندارد.
</p>

### سوال ۴

<p dir="rtl" style="text-align: right">
در حالتی که ابعاد مستطیل قابل تغییر باشد، کلاس  مربع از کلاس مستطیل نمی‌تواند ارث بری کند (زیرا تنها یک ضلع دارد و در نتیجه تابع setY برای آن به معنی می‌شود که برخلاف اصول SOLID است) و 
بالعکس، زیرا اصل Liskov Substitution Principle نقض می‌شود و در نتیجه اصول SOLID رعایت نمی‌شود. 
 حال اگر ابعاد مستطیل تغییر نکند کلاس مستطیل دیگر توابع Set را ندارد و در نتیجه کلاس مربع می‌تواند از کلاس مستطیل 
ارث بری کند زیرا تمام توابع آن را به ارث ‌می‌برد و صرفا با تعریف یک Constructor می‌تواند این ارث‌بری 
را انجام بدهد و در این حالت اصول SOLID نیز رعایت می‌شود.
 همچنین در حالت اولیه برای حل مشکل گفته شده یک کلاس abstract به نام Shape تعریف کردیم که کلاس‌های مستطیل و مربع 
هر دو از آن ارث بری می‌کنند و ویژگی‌های مشترک این دو کلاس، در کلاس Shape قرار داده شدند.
</p>