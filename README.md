## آزمایش ۵

### SOLID

#### Single Responsibility Principle

 <p dir="rtl"  style='text-align: right;'>
این اصل در طراحی SOLID به این معنی است که یک کلاس فقط باید به یک Actor پاسخگو باشد 
یا به عبارتی فقط باید یک کار انجام دهد.
</p>

#### Open Closed Principle

<p dir="rtl" style='text-align: right;'>
این اصل به این معنی است که کلاس‌ها قابلیت گسترش داشته باشند اما نیازی به تغییر 
کد اولیه نباشد برای این گسترش و ویژگی‌های جدید اضافه شده.
</p>

#### Liskov Substitution Principle

<p dir="rtl" style="text-align: right">
با پیاده سازی این اصل زمانی که از یک کلاس پدر استفاده می‌شود بدون اینکه اطلاعاتی 
راجع به فرزند آن بدانیم باید بتوانیم از ویژگی‌های پدر استفاده کنیم. به عبارتی 
این اصل را می‌توان اینطور بیان کرد:
<br>
 فرض کنیم (q(x یک ویژگی قابل اثبات در مورد شی x از نوع پدر است.
آنگاه(q(y باید برای شی y از نوع فرزند درست باشد. (فرزند همان کلاس قبل)
</p>

#### Interface Segregation Principle

<p dir="rtl" style="text-align: right">
در این اصل یک کلاس نباید مجبور به پیاده سازی یک interface شود که از آن استفاده نمی‌کند.
یا می‌توان اینطور برداشت کرد که همیشه استفاده از interface های کوچک‌تر بهتر از استفاده از interface‌های
بزرگ‌تر است.
</p>

#### Dependency Inversion Principle

<p dir="rtl" style="text-align: right">
در این اصل کلاس‌های سطح بالاتر نباید از ویژگی‌های کلاس سطح پایین‌تر نباید 
استفاده کنند و روابط بین کلاس‌ها باید از نوع abstraction باشد. همچنین در 
این abstraction ها نباید جزییات کلاس‌ها پیاده سازی شوند و این جزییات باید 
در کلاس‌های سطح پایین تر پیاده‌سازی شوند. این اصل باعث می‌شود در صورت تغییر در 
کلاس‌های سطح پایین‌تر نیازی نباشد تا در کلاس‌های سطح بالا نیز تغییری ایجاد کنیم.
</p>


### سوال ۲

<p dir="rtl" style="text-align: right">
از اصل Single Responsibility Principle بیشتر در فاز طراحی و کمی در فاز پیاده‌سازی استفاده می‌شود. زیرا 
این اصل بر مسئولیت‌های کلاس‌ها و ماژول‌ها تاکید می‌کند در نتیجه بیشتر در فاز طراحی مهم است. 
از اصل Open Closed Principle نیز بیشتر در فاز پیاده‌سازی استفاده می‌شود هرچند که فاز پیاده‌سازی نیز برای 
این اصل مهم است. از‌ آنجایی که این اصل بر این موضوع تاکید دارد که کلاس‌ها توسعه پذیر باشند، این مورد 
بیشتر به پیاده‌سازی درست مربوط می‌شود و تا حدودی طراحی درست.
از اصل Liskov Substitution Principle نیز بیشتر در فاز طراحی استفاده می‌شود. زیرا در این فاز باید روابط بین کلاس‌ها 
مشخص می‌شوند که این مورد در فاز طراحی انجام می‌شود. همچنین تا حدودی هم بر فاز پیاده‌سازی تاثیر می‌گذارد.
اصل Interface Segregation Principle نیز بیشتر در مرحله طراحی استفاده می‌شود زیرا در این مرحله باید 
interface ها طراحی شوند و اینکار باید به گونه‌ای انجام شود که 
کلاس‌ها توابعی را پیاده سازی نکنند که استفاده‌ای برای‌شان ندارند.
اصل Dependency Inversion Principle نیز مانند اصل قبلی بیشتر در مرحله طراحی استفاده می‌شود. زیرا برای این اصل 
ارتباط بین کلاس‌ها باید به گونه‌ای طراحی شود که تغییر در کلاس‌های سطح پایین منجر به تغییر به کلاس‌های 
پدر و سطح بالاتر نشود که این کار بیشتر در مرحله طراحی انجام می‌شود.
</p>

### سوال ۳
<p dir="rtl" style="text-align: right">
خیر؛ در روش TDD، نوشتن تست‌ها جزئی از فرآیند Development هستند. در این روش ابتدا تست‌ها نوشته می‌شوند و 
باقی قسمت Development با استفاده از آن‌ها انجام می‌شود و کدها با توجه تست‌ها زده می‌شوند به طوری که 
بتوانند آنها را پاس کنند. در نتیجه این روش‌های مختلف با هم تناقضی ندارند.
</p>

### سوال ۴
<p dir="rtl" style="text-align: right">
در حالتی که ابعاد مستطیل قابل تغییر باشد، کلاس  مربع از کلاس مستطیل نمی‌تواند ارث بری کند و 
بالعکس زیرا اصل Liskov Substitution Principle نقض می‌شود. 
 حال اگر ابعاد مستطیل تغییر نکند کلاس مربع می‌تواند از کلاس مستطیل 
ارث بری کند زیرا تمام توابع آن را به ارث ‌می‌برد.
</p>