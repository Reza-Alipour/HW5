## آزمایش ۵

### SOLID

#### Single Responsibility Principle

 <p dir="rtl"  style='text-align: right;'>
این اصل در طراحی SOLID به این معنی است که یک کلاس فقط باید به یک Actor پاسخگو باشد 
یا به عبارتی فقط باید یک کار انجام دهد.
</p>

#### Open Closed Principle

<p dir="rtl" style='text-align: right;'>
این اصل به این معنی است که کلاس‌ها قابلیت گسترش داشته باشند اما نیازی به تغییر 
کد اولیه نباشد برای این گسترش و ویژگی‌های جدید اضافه شده.
</p>

#### Liskov Substitution Principle

<p dir="rtl" style="text-align: right">
با پیاده سازی این اصل زمانی که از یک کلاس پدر استفاده می‌شود بدون اینکه اطلاعاتی 
راجع به فرزند آن بدانیم باید بتوانیم از ویژگی‌های پدر استفاده کنیم. به عبارتی 
این اصل را می‌توان اینطور بیان کرد:
<br>
 فرض کنیم (q(x یک ویژگی قابل اثبات در مورد شی x از نوع پدر است.
آنگاه(q(y باید برای شی y از نوع فرزند درست باشد. (فرزند همان کلاس قبل)
</p>

#### Interface Segregation Principle

<p dir="rtl" style="text-align: right">
در این اصل یک کلاس نباید مجبور به پیاده سازی یک interface شود که از آن استفاده نمی‌کند.
یا می‌توان اینطور برداشت کرد که همیشه استفاده از interface های کوچک‌تر بهتر از استفاده از interface‌های
بزرگ‌تر است.
</p>

#### Dependency Inversion Principle

<p dir="rtl" style="text-align: right">
در این اصل کلاس‌های سطح بالاتر نباید از ویژگی‌های کلاس سطح پایین‌تر نباید 
استفاده کنند و روابط بین کلاس‌ها باید از نوع abstraction باشد. همچنین در 
این abstraction ها نباید جزییات کلاس‌ها پیاده سازی شوند و این جزییات باید 
در کلاس‌های سطح پایین تر پیاده‌سازی شوند. این اصل باعث می‌شود در صورت تغییر در 
کلاس‌های سطح پایین‌تر نیازی نباشد تا در کلاس‌های سطح بالا نیز تغییری ایجاد کنیم.
</p>


### سوال ۳
<p dir="rtl" style="text-align: right">
در حالتی که ابعاد مستطیل قابل تغییر باشد، کلاس  مربع از کلاس مستطیل نمی‌تواند ارث بری کند و 
بالعکس زیرا اصل Liskov Substitution Principle نقض می‌شود. 
 حال اگر ابعاد مستطیل تغییر نکند کلاس مربع می‌تواند از کلاس مستطیل 
ارث بری کند زیرا تمام توابع آن را به ارث ‌می‌برد.
</p>